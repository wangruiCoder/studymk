# Mysql 学习笔记
---

## 4K 对齐


## mysql 性能监控
- mysql profiles
- performance_schema
    > 5.7 版本后才加入，之前使用mysql profiles。但是官网说以后`mysql profiles`会被废弃


## 第一章 数据类型优化
整体原则

- 更小的通常更好（预估字段长度选择合适的数据类型存储）
- 简单表示最好（尽量采用简单标识表示数据内容）
- 尽量避免null（如果非必要尽量让列的都带有默认值）

### 1.1 整数类型
存储整数时需要根据实际数据长度选择使用`tinyint smallint int bigint`等。数据类型不同存储占用的空间不同。

### 1.2 字符类型
#### 1.2.1 char固定长度字符串
- 最大长度255
- 会自动删除末尾的空格
- 检索效率、写效率比varchar高

> - 一般用于存储长度波动不大的数据，如MD5
- 短字符串，经常更新的字符串

#### 1.2.2 varchar可变长字符串
每次更新后都会重新计算存储空间，性能相比char较差
> 可变长字符串
#### 1.2.3 BLOB+TEXT

### 1.3 日期类型
datetime time timestamp
#### 1.3.1 datetime
- 占用8个字符
- 与时区无关
- 可保存到毫秒
- 可保存日期范围大

#### 1.3.2 timestamp
- 占用4个字节
- 时间范围小 1970-01-01 - 2038-01-19
    > 因为int的最大值范围是（2的31次方），经过计算智能存储到2038年
- 精确到秒
- 采用整形存储
- 依赖数据库设置的时区

#### 1.3.3 date
- 占用3个字节
- 使用date类型可以利用时间函数进行日期间的计算
- date类型可以保存1000-01-01到9999-12-31之间的日期

### 1.4 范式和反范式
#### 1.4.1 范式
一二三范式目的是减少冗余字段
1NF:字段不可分
2NF:保证一张表只描述一件事情,没有部分依赖
3NF:非主键字段不能相互依赖,没有传递依赖,依赖于外键关联
- 优点
    1. 范式的更新通常比较快
    2. 
- 缺点
可能需要关联查询

### 1.5 主键的选择
- 代理主键(推荐)
> 与业务无关的，无意义的数字序列
- 自然主键
> 事务属性中的自然唯一标识

### 1.6 字符集的选择
- 如果存储不超过拉丁文范围的就选择latin1
- 如果需要存放多种语言就可以选择UTF8 Unicode字符类型

### 1.7 存储引擎的选择
- memory 不建议使用
- innerDB
- MyISAM
![](1.png)

### 1.8 适当的数据冗余
适当的数据容易可以减少关联查询提升查询效率，同时减少IO

### 1.9 适当的拆分
- 垂直拆分
按照业务需求将不同的业务表拆分到不同库中
- 水平拆分
将一个表的数据拆分到不同的库表中

## 第二章 索引优化

### 2.1 为什么使用B+树
不使用其他树是因为其他树可能出现不平衡和树节点过深导致的查询效率降低的问题。

### 2.2 索引优点
- 大大减少了服务器需要扫描的数据量
- 帮助服务器避免排序和临时表
- 将随机IO变成顺序IO

### 2.3 索引的用处
- 快速查找匹配where子句的行
- 从consideration中消除行，如果可以在多个索引之间选择，mysql通常会使用找到最少行的索引
- 如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找
- 当有表连接的时候，从其他表检索行数据
- 查找特定索引列的min和max值
- 如果排序或分组时可用索引的最左前缀上完成的，则对表进行排序和分组
- 在某些情况下，可以优化查询以检索值而无需查询数据行

### 2.4 索引的分类
- 主键索引
- 唯一索引
- 普通索引
- 全文索引
- 组合索引

### 2.5 技术名词
- 回表
    > 普通索引会发生回表，原理是普通索引的最底层存储的是主键的id值，当索引到某一列时会获取到当前列的数据对应的主键，然后根据主键索引再查询一遍数据
- 覆盖索引
- 最左匹配
- 索引下推

### 2.6 索引的匹配方式
- 全值匹配
- 匹配最左前缀
- 匹配列前缀
- 匹配范围值
- 精确匹配到某一列并范围匹配到另外一列
- 只访问索引的查询


### 2.7 hash 索引
- 基于hash表的实现，只有精确匹配索引所有列的查询才有效
- 只有在memory引擎中才有

### 2.8 组合索引

### 2.9 聚簇索引和非聚簇索引
- 聚簇索引
    > innerdB使用的都是聚簇索引，因为索引和数据在同一个文件中保存
- 非聚簇索引
    > MyISAM使用的是非聚簇索引，因为索引是一个文件，数据在另外一个文件中保存

> 聚簇索引比非聚簇索引少了好多次的磁盘IO

### 2.10 覆盖索引
- 如果一个索引包含了所有需要查询的字段的值，我们称之为覆盖索引。
- 覆盖索引必须存储列的值

### 2.11 优化小细节
- 使用索引列进行查询的时候尽量不要使用表达式，把计算逻辑放到业务层
- 尽量使用主键查询，而不是其他索引，主键查询不会触发回表查询
- 使用前缀索引(如果一个列的数据长度比较长的时候选择当前列的前多少位作为索引，但是一定要保证前几位尽量是唯一的)
- 使用索引扫描来排序操作（order by 中尽量使用索引列进行排序）
- union all，in or 都能够使用索引，但是推荐使用in
- 范围列可以用到索引,但是范围查询只能用到一个范围索引，范围条件后的索引就会失效
    > 范围条件 `> < >= <= between`
- 强制类型转换会表扫描
- 更新频繁的字段不建议建立索引
- 创建索引的列不允许为null
- 如果明确知道只要一条结果返回，limit 1 能够提高效率
- 单索引字段数不允许超过5个
- 单表索引建议控制在5个以内
- 避免过早优化，在不了解系统的情况下进行优化

## 第三章 索引的监控信息
show status like 'Handler_read%'

## 第四章 查询优化
### 4.1 查询慢的原因
- 网络
- CPU
- IO
- 上下文切换
- 系统调用
- 生成统计信息
- 锁等待时间
    > 自增锁、间隙锁、共享读锁，排他写锁（表锁、行锁）。锁与存储引擎有关，Myisam只能锁表。innerdb可以锁表和行

### 4.2 优化数据访问
- 减少数据访问量的方式进行优化。访问低于30%的数据量

- 是否向数据库请求了不需要的数据
    1. 查询不需要的记录
        > 设置只查询需要的列
    2. 多表关联返回全部列
        > 多表一定要有别名，根据需求只查询部分列
    3. 总是取出全部列
        > 根据实际需要查询需要的列
    4. 重复查询相同的数据
        > 如果一直会查询相同的数据，应该使用查询缓存，例如redis

### 4.3 执行过程的优化
- 查询缓存开启
    > 经常不变的数据可以启用查询缓存，但是从8.0后 mysql已经去掉了查询缓存的功能

- 查询优化处理
    1. 语法解析器和预处理
    2. 查询优化器
        1. 优化策略（静态优化，动态优化）
        2. 优化器类型
            - 重新定义关联表的查询
            - 将外连接转为内连接
            - 优化count min max
            - 尽量使用常数表达式提高查询效率
            - 索引覆盖扫描
            - 


`SHOW STATUS LIKE 'last_query_cost'` 显示上一次查询需要用的数据页

## 第五章 自定义变量


## 第六章 分区表

### 6.1 应用场景
- 可以备份和恢复独立的分区
- 避免某些特殊的瓶颈（innerDB 单个索引互斥访问，ext3 文件系统的inode锁竞争）
- 分区表数据可以分布在不同的物理设备上，从而高效的利用多个硬件

### 6.2 分区表的限制
- 一个表最多支持1024个分区（因为操作系统的fd 文件描述符），在5.7 版本的时候可以支持8196个
- 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来
- 分区表无法使用外键约束（可以选择软外键）


